인자전달의 기본방식은 값의 복사이다.

함수호출 시 전달되는 인자의 값은 매개변수에 복사가 된다.


void ShowArayElem(int * param, int len){ ... }
void ShowArayElem(int param[], int len){ ... }

일반적으로 배열의 주소 값이 인자로 전달될 때에는 int param[] 형태의 선언을 주로 많이 사용한다. 하지만 이 둘이 같은 선언으로 간주되는 경우는 매개 변수의 선언으로 제한된다.


함수 내에서는 인자로 전달된 배열의 길이를 계산할 수 없다.
배열의 주소 값을 인자로 전달받는 매개변수는 포인터 변수이기 떄문에 이를 대상으로 sizeof 연산을 할 경우 배열의 크기가 반환되지 않고 포인터 변수의 크기가 반환된다. 이렇듯 함수 내에서는 인자로 전달된 배열의 길이를 계산할 수가 없기 때문에 배열의 크기나 길이정보도 함께 인자로 전달해야 한다.



Call-by-value와 Call-by-reference는 함수의 호출방식을 의미한다. 인자전달에서 인자의 자료형이 포인터형인지 일반 자료형인지이다. 

값을 전달하는 형태의 함수호출 Call-by-value
함수를 호출할 때 단순히 값을 전달하는 형태의 함수호출을 의미한다.

주소 값을 전달하는 형태의 함수호출 Call-by-reference
메모리의 접근에 사용되는 주소 값을 전달하는 형태의 함수호출 Call-by-reference

int main(void){
	int num;
	scanf("%d", &num);
}
이제는 scanf 함수호출 시 & 연산자를 붙이는 이유를 알 수 있다.
scanf 함수호출이 완료되면 변수 num에는 값이 채워진다. 즉 프로그램 사용자로부터 값을 입력받아서 변수 num에 그 값을 채우는 일을 scanf 함수가 하는 것이다. 그리고 이를 위해서 scanf함수는 변수 num의 주소값을 알아야 한다. 
scanf 함수의 호출은 결국 Call-by-reference 형태의 함수호출에 해당한다.


포인터 변수가 참조하는 대상의 변경을 허용하지 않는 const선언

int main(void){
	int num = 20;
	const int * ptr = &num;
	*ptr = 30;		//컴파일 에러
	num = 40;	//컴파일 성공
}

const가 맨 앞부분에 선언이 되면, 포인터 변수 ptr을 이요해서 ptr이 가리키는 변수에 저장된 값을 변경하는 것을 허용하지 않는다는 의미이다. 그렇다고 해서 포인터 변수 ptr이 가리키는 변수 num이 상수화 되는 것은 아니다. 따라서 다음과 같이 변수 num에 저장된 값을 변경하는 것은 허용이 된다.
num = 40;

포인터 변수의 상수화
int * const ptr = &num;
이렇게 되면 포인터 변수 ptr은 상수가 된다. 포인터 변수 ptr이 상수라는 뜻은 한번 주소 값이 저장되면 그 값의 변경이 불가능하다는 뜻이다.

int main(void){
	int num1 = 20;
	int num2 = 30;
	int * const ptr = &num1;
	ptr = &num2;	//컴파일 에러
	*ptr = 40;		//컴파일 성공
	return 0;
}

하나의 포인터 변수를 대상으로 이 두가지 형태의 const 선언을 동시에 할 수도 있다.
const int * const ptr = &num;

const선언을 사용하므로써 프로그램의 안정성을 높일 수 있다.






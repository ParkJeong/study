데이터의 이동경로를 의미하는 스트림

프로그램을 중심으로 프로그램 안으로 데이터가 흘러 들어오는 것이 입력이고, 프로그램 밖으로 데이터가 흘러 나가는 것이 출력이다.

운영체제는 외부장치와 프로그램과의 데이터 송수신의 도구가 되는 스트림을 제공하고 있다.

콘솔 입출력을 위한 입력 스트림과 출력 스트림은 프로그램이 실행되면 자동으로 생성되고, 프로그램이 종료되면 자동으로 소멸되는 스트림이다.

stdin 	/ 표준 입력 스트림 / 키보드 대상으로 입력
stdout	/ 표준 출력 스트림 / 모니터 대상으로 출력
stderr	/ 표준 에러 스트림 / 모니터 대상으로 출력


스트림은 한 방향으로 흐르는 데이터의 흐름을 뜻한다. 즉 스트림이란 단어에는 단 방향으로만 데이터의 전송이 이뤄진다는 뜻이 담겨 있다. 실제로 입출력 스트림도 입력 스트림과 출력 스트림이 구분되어서 한 방향으로만 데이터의 흐름을 유지하고 있다.



문자 출력함수: putchar, fputc
모니터로 하나의 문자를 출력할 때 일반적으로 사용하는 두 함수
#include <stdio.h>
int puchar(int c);
int fputc(int c, FILE * stream);

putchar 함수는 인자로 전달된 문자정보를 stdout으로 표현되는 표준 출력 스트림으로 전송하는 함수이다. 문자를 전송한다는 측면에서는 fputc 함수도 putchar 함수와 동일하다. 단, fputc 함수는 문자를 전송할 스트림을 지정할 수 있다.
즉 fputc 함수를 이용하면 stdout뿐만 아니라, 파일을 대상으로도 데이터를 전송할 수 있다.
fputc 함수의 두 번째 매개변수 stream은 문자를 출력할 스트림의 지정에 사용된다. 따라서 이 인자에 표준 출력 스트림을 의미하는 stdout을 전달하면, putchar 함수와 동일한 함수가 된다.
비정상적인 종료를 할 경우 EOF를 반환한다.


문자 입력 함수: getchar, fgetc
키보드로부터 하나의 문자를 입력 받을 떄 일반적으로 사용하는 두 함수
#include <stdio.h>
int getchar(void);
int fgetc(FILE * stream);

파일의 끝에 도달하거나 함수호출 실패 시 EOF 반환


EOF는 End Of File의 약자로서, 파일의 끝을 표현하기 위해서 정의해 놓은 상수이다. 

키보드를 대상으로 하는 fgetc 함수와 gerchar 함수는 언제 EOF를 반환할까? 이는 다음 두 가지 경우 중 하나가 만족되었을 때다.
1. 함수 호출의 실패
2. Windows에서 CTRL+Z키, Linux에서 CTRL+D키가 입력되는 경우

키보드의 입력에 파일의 끝이라는 것이 존재하지 않는다.그래서 EOF를 의미하는 CTRL+Z또는 CTRL+D키의 입력으로 별도로 약속해 놓은 것이다.


반환형이 int이고 int형 변수에 문자를 담는 이유는?
int getchar(void);
int fgetc(FILE * stream);

EOF는 -1로 정의된 상수이다. 따라서 반환형이 char형이라면, 그리고 char를 unsigned char로 처리하는 컴파일러에 의해서 컴파일이 되었다면, EOF는 반환의 과정에서 엉뚱한 양의 정수로 형 변환이 되어버린다. 그래서 어떠한 상황에서도 -1을 인식할 수 있는 int형으로 반환형을 정의해 놓은 것이다.

문자 단위 입출력 함수의 존재이유
단순히 문자 하나를 입출력하는 것이 목적이라면 printf함수나 scanf 함수를 사용하는 것보다 앞서 새로 소개한 함수들을 사용하는 것이 성능적으로 더 낫다.




문자열 출력 함수: puts, fputs
모니터로 하나의 문자열을 출력할 때 일반적으로 사용하는 두 함수는 다음과 같다.
#include <stdio.h>
int puts(const char * s);
int fputs(const char * s, FILE * stream);

puts함수는 출력의 대상이 stdout으로 결정되어 있지만, fputs함수는 두 번째 인자를 통해서 출력의 대상을 결정할 수 있다.

puts함수는 자동으로 개행이 이뤄지지만, fputs 함수는 문자열 출력 후 자동으로 개행이 이뤄지지 않는다.


문자열 입력 함수:gets, fgets
#include <stdio.h>

int gets(char * s);
int fgets(char * s, int n, FILE * stream);

gets함수는 미리 마련해 놓은 배열을 넘어서는 길이의 문자열이 입력되면, 할당 받지 않은 메모리 공간을 침범하여 실행 중 오류가 발생한다는 단점이 있다. 그래서 가급적이면 다음의 형태로 fgets 함수를 호출하는 것이 좋다.

int main(void){
	char str[7];
	fgets(str, sizeof(str), stdin);
}
stdin으로부터 문자열을 입력 받아서 배열 str에 저장하되, sizeof(str)의 길이만큼만 저장하라는 의미이다.

+문자열을 입력 받으면 문자열의 끝에 자동으로 널 문자가 추가된다. 널 문자가 삽입되지 않으면 문자열이 아니기 때문이다.

scanf함수를 통해서는 공백을 포함하는 형태의 문자열을 입력 받을 수 없다.


표준 입출력 함수를 통해서 데이터를 입출력 하는 경우, 해당 데이터들은 운영체제가 제공하는 메모리 버퍼를 중간에 통과하게 된다. 여기서 말하는 메모리 버퍼는 데이터를 임시로 모아두는 (저장하는)메모리 공간이다. 

키보드를 통해 입력되는 데이터는, 일단 입력버퍼에 저장된 다음에(버퍼링 된 다음에) 프로그램에서 읽혀진다. 즉 fgets 함수가 읽어 들이는 문자열은 입력버퍼에 저장된 문자열이다. 그럼 키보드로부터 입력된 데이터가 입력 스트림을 거쳐서 입력버퍼로 들어가는 시점은 언제일까? 이는 엔터 키가 눌리는 시점이다. 그래서 키보드로 아무리 문자열을 입력해도 엔터 키가 눌리기 전에는 fgets 함수가 문자열을 읽어 들이지 못하는 것이다. 엔터 키가 눌리기 전에는 입력버퍼가 비워져 있으니 말이다.


버퍼링을 하는 이유?
데이터를 목적지로 바로 전송하지 않고 중간에 출력버퍼와 입력버퍼를 둬서 전송하고자 하는 데이터를 임시 저장하는 이유는 무엇일까? 이러한 데이터 버퍼링의 가장 큰 이유는 데이터 전송의 효율성과 관련이 있다.

키보드나 모니터와 같은 외부장치와의 데이터 입출력은 생각보다 시간이 걸리는 작업이다. 따라서 버퍼링 없이 키보드가 눌릴 때마다 눌린 문자의 정보를 목적지로 바로 이동시키는 것보다 중간에 메모리 버퍼를 둬서 데이터를 한데 묶어서 이동시키는 것이 보다 효율적이고 빠르다.

창고에 물건을 나르는 경우 손으로 하나씩 나르는 것보다 손수레에 가득 채워서 나르는 것이 보다 빠르고 효율적이라는 것을 알고 있다. 입출력의 과정에서 버퍼링을 했을 때 보다 빠르고 효율적인 이유도 이와 같은 이치이다.



출력 버퍼를 비우는 fflush함수
출력 버퍼가 비워진다는 것은 출력버퍼에 저장된 데이터가 버퍼를 떠나서 목적지로 이동됨을 뜻한다. 출력버퍼가 비워지는 시점은 시스템에 따라 그리고 버퍼의 성격에 따라 달라진다.
예를 들어 버퍼가 꽉 찼을 떄 비워지는 버퍼도 있고, 하나의 문장이 완전히 입력되었을 때마다 비워지는 버퍼도 있다.

#include <stdio.h>
int fflush(FILE * stream);

위 함수는 인자로 전달된 스트림의 버퍼를 비우는 기능을 제공한다.
fflush(stdout); // 표준 출력버퍼를 비워라

어떠한 시스템의 어떠한 표준 출력버퍼라 할지라도 버퍼에 저장된 내용이 비워지면서 데이터가 목적지로 이동한다.


입력버퍼의 비워짐은 출력버퍼의 비워짐과 개념적으로 차이가 있다. 출력버퍼의 비워짐이 저장된 데이터가 목적지로 전송됨을 의미한다면, 입력버퍼의 비워짐은 데이터의 소멸을 의미하기 때문이다.
fflush함수는 출력버퍼를 대상으로 호출하는 함수이다.

입력버퍼를 비우려면 따로 함수를 정의해야 한다.
void ClearLineFromReadBuffer(void){
	while(getchar() != '\n');
}




문자열의 길이를 반환하는 함수: strlen
#include <string.h>
size_t strlen(const char * s);
전달된 문자열의 길이를 반환하되, 널 문자는 길이에 포함하지 않는다.

typedef unsigned int size_t
-> unsigned int의 선언을 size_t로 대신할 수 있다.
unsigned int len;
size_t len;
위의 두 코드는 동일하다.


strlen 함수의 반환 값을 int형 변수에 저장하고 서식문자 %d로 출력하는 것도 가능할 뿐만 아니라 이것이 더 흔하다.


문자열을 복사하는 함수들: strcpy, strncpy
#include <stdio.h>
char * strcpy(char * dest, const char * src);
char * strncpy(char * dest, const char * src, size_t n);
복사된 문자열의 주소 값 반환

int main(void){
	char str1[30]="Simple String";
	char str2[30];
	strcpy(str2, str1);	//	str1의 문자열을 str2에 복사
}

strncpy 함수
str1에 저장된 문자열을 str2에 복사하되, str1의 길이가 매우 길다면, sizeof(str2)가 반환한 값에 해당하는 문자의 수 만큼만 복사를 진행해라

int main(void){
	char str1[30] = "Simple String";
	char str2[30];
	strncpy(str2, str1, sizeof(str2));
}





